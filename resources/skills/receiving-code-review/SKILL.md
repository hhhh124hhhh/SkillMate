---
name: receiving-code-review
description: |
  接收代码审查 - 当接收审查反馈、在实施建议之前使用此技能。
  需要技术严谨性和验证，而非表演性同意或盲目实施。当用户需要：处理代码审查意见、改进代码质量时触发此技能。
---

# 接收代码审查

## 概述

有效接收代码审查反馈需要技术严谨性、批判性思维和验证。

**核心原则**：理解 → 验证 → 实施 → 证明，而非盲目同意。

**开始时声明**："我正在使用 receiving-code-review 技能处理此反馈。"

## 何时使用

**总是使用**，当：
- 收到 Pull Request 审查意见
- 收到代码审查反馈
- 被要求修改代码
- 不确定反馈是否正确

**特别在以下情况下使用**：
- 反馈似乎技术上可疑
- 建议可能引入新问题
- 反馈与已知最佳实践冲突
- 不理解反馈的原因

## 处理流程

### 阶段 1：理解反馈

#### 步骤 1：仔细阅读

**不要急于修改**。先理解反馈：
- 审查者指出了什么问题？
- 为什么这是问题？
- 建议的解决方案是什么？
- 影响范围是什么？

**提问**：
- "您能解释一下为什么这会导致问题吗？"
- "这个建议会带来什么权衡？"
- "有具体示例说明问题吗？"

#### 步骤 2：验证有效性

**关键**：并非所有反馈都是正确的。

**验证方法**：

1. **查阅文档**
   - 官方文档怎么说？
   - 最佳实践是什么？
   - 有权威来源支持吗？

2. **测试当前代码**
   ```bash
   # 当前代码真的有问题吗？
   npm test
   # 运行特定测试
   npm test -- --testNamePattern "scenario"
   ```

3. **重现问题**
   ```bash
   # 审查者描述的问题能否重现？
   # 添加日志验证
   console.log('Debug:', value);
   ```

4. **分析权衡**
   ```bash
   # 建议的修改会：
   # - 修复问题吗？✅
   # - 引入新问题吗？❓
   # - 影响性能吗？❓
   # - 降低可读性吗？❓
   ```

#### 步骤 3：形成判断

基于验证，形成技术判断：

**反馈有效**：
- ✅ 有明确证据支持
- ✅ 符合最佳实践
- ✅ 改进代码质量
- ✅ 不引入新问题

→ **实施修改**

**反馈无效**：
- ❌ 缺乏技术依据
- ❌ 与最佳实践冲突
- ❌ 会引入新问题
- ❌ 降低代码质量

→ **讨论和澄清**

**反馈部分有效**：
- ⚠️ 核心问题正确
- ⚠️ 建议方案有问题

→ **讨论替代方案**

### 阶段 2：讨论和澄清

#### 场景 1：反馈不明确

**回复模板**：
```markdown
感谢审查！关于这条反馈：

> [原始反馈]

我理解您关注 [问题]。但我需要澄清：

1. 具体场景是 [描述场景]
2. 当前行为是 [描述行为]
3. 您建议的修改会导致 [预测结果]

这是否符合您的预期？或者我们应该：
- [选项 A]
- [选项 B]

请问您的想法？
```

#### 场景 2：反馈似乎不正确

**回复模板**：
```markdown
感谢反馈！关于这条建议：

> [原始反馈]

我查看了相关资料：
- [文档/来源 1] 说 [内容]
- [最佳实践] 是 [内容]
- 我的测试显示 [结果]

基于此，我的理解是：
- 当前实现 [为什么正确]
- 建议的修改可能 [潜在问题]

我的判断是否准确？或者我遗漏了什么？
```

#### 场景 3：需要权衡讨论

**回复模板**：
```markdown
好的建议！但这涉及一些权衡：

**当前方案**：
- 优点：[优点 1, 2]
- 缺点：[缺点 1]

**建议方案**：
- 优点：[优点 1]
- 缺点：[缺点 1, 2]

我的考虑是 [分析]。您认为：
- 是否值得这个权衡？
- 有没有更好的方案？

期待您的想法！
```

### 阶段 3：实施修改

#### 步骤 1：规划修改

**如果同意修改**：
1. 列出具体修改点
2. 识别影响范围
3. 规划测试策略
4. 评估回归风险

**清单**：
- [ ] 需要修改哪些文件？
- [ ] 需要添加哪些测试？
- [ ] 需要更新哪些文档？
- [ ] 可能影响哪些现有功能？

#### 步骤 2：TDD 方法

**重要**：使用测试驱动开发方法修改代码。

1. **添加失败测试**
   ```typescript
   test('should handle edge case suggested by reviewer', () => {
     // 审查者指出的场景
     const result = function(edgeCaseInput);
     expect(result).toBe(expected);
   });
   ```

2. **验证测试失败**
   ```bash
   npm test -- --testNamePattern "edge case"
   # 应该 FAIL，证明问题存在
   ```

3. **实施修改**
   ```typescript
   function function(input) {
     // 修复代码
   }
   ```

4. **验证测试通过**
   ```bash
   npm test -- --testNamePattern "edge case"
   # 应该 PASS
   ```

5. **验证回归测试**
   ```bash
   npm test
   # 所有测试应该 PASS
   ```

#### 步骤 3：验证修改

**不要假设修改有效**。验证：

**功能验证**：
```bash
# 单元测试
npm test

# 集成测试
npm run test:integration

# 手动测试
# 运行应用，验证场景
```

**性能验证**：
```bash
# 性能测试
npm run benchmark

# 对比前后
git diff HEAD~1
```

**回归验证**：
```bash
# 确保没有破坏现有功能
npm test

# 检查相关功能
npm run test:affected
```

### 阶段 4：响应和关闭

#### 步骤 1：响应反馈

**如果实施修改**：
```markdown
✅ 已实施此反馈

**修改**：
- 修改了 [文件]:[行]
- 添加了测试 [测试名称]
- 更新了文档 [文档名称]

**验证**：
- [x] 新测试通过
- [x] 所有测试通过
- [x] 手动测试通过

请审查修改后的代码。
```

**如果讨论后决定不修改**：
```markdown
经过讨论，我们决定：

[最终决定的原因]

感谢您的建议！
```

#### 步骤 2：标记反馈

**使用 PR 评论功能**：
- ✅ 已解决
- ❌ 不适用
- 💬 需要讨论

## 常见陷阱

### 陷阱 1：盲目实施

**症状**：
- 不验证就修改
- 不理解原因就同意
- 机械地应用反馈

**后果**：
- 引入新 bug
- 降低代码质量
- 错失学习机会

**解决**：
- 验证每个反馈
- 理解背后的原因
- 质疑可疑的建议

### 陷阱 2：防御性回应

**症状**：
- 过度解释和辩解
- 把反馈当作批评
- 情绪化反应

**后果**：
- 阻碍建设性讨论
- 破坏团队信任
- 错失改进机会

**解决**：
- 保持开放心态
- 把反馈当作学习机会
- 关注问题而非自我

### 陷阱 3：表面修改

**症状**：
- 只修改表面问题
- 不解决根本原因
- 回避重构

**后果**：
- 技术债务累积
- 问题重复出现
- 代码质量下降

**解决**：
- 解决根本问题
- 必要时重构
- 提升代码质量

### 陷阱 4：不验证修改

**症状**：
- 修改后不测试
- 假设修改有效
- 不检查回归

**后果**：
- 引入新 bug
- 破坏现有功能
- 信任受损

**解决**：
- TDD 方法修改
- 完整测试验证
- 确保无回归

## 与其他技能的集成

**工作流程**：
1. **requesting-code-review** - 请求审查
2. **receiving-code-review** - 处理反馈 ⬅️ 这里
3. **systematic-debugging** - 如果修改引入问题
4. **verification-before-completion** - 完成前验证

## 快速参考

| 反馈类型 | 处理方式 |
|---------|---------|
| **明确且正确** | 理解 → TDD 修改 → 验证 → 响应 |
| **明确但可疑** | 验证 → 讨论 → 决定 |
| **不明确** | 澄清 → 理解 → 决定 |
| **部分正确** | 讨论替代方案 → 达成共识 |

## 关键原则

- **技术严谨**：验证每个反馈，不盲目同意
- **批判性思维**：质疑可疑建议，寻求证据
- **建设性讨论**：开放对话，寻求最佳方案
- **TDD 修改**：用测试验证修改有效
- **完整验证**：确保修改不引入新问题
- **持续学习**：把审查当作学习机会

## 依赖要求

- 无需特殊依赖
- 需要 TDD 工作流程知识
- 需要 systematic-debugging 技能（如果修改引入问题）
