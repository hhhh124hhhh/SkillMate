---
name: systematic-debugging
description: |
  系统化调试 - 在遇到任何 bug、测试失败或意外行为时使用，在建议修复之前使用。
  总是在尝试修复之前找到根本原因。症状修复就是失败。当遇到 bug、错误、异常行为时触发此技能。
---

# 系统化调试

## 概述

随机修复浪费时间并创建新 bug。快速补丁掩盖潜在问题。

**核心原则**：在尝试修复之前始终找到根本原因。症状修复就是失败。

**违反此过程的字面意思就是违反调试的精神。**

## 铁律

```
没有根本原因调查就没有修复
```

如果你没有完成第一阶段，就不能提出修复。

## 何时使用

用于任何技术问题：
- 测试失败
- 生产环境 bug
- 意外行为
- 性能问题
- 构建失败
- 集成问题

**特别在以下情况下使用**：
- 时间压力（紧急情况使猜测诱人）
- "只是一个快速修复"似乎很明显
- 你已经尝试了多个修复
- 之前的修复不起作用
- 你不完全理解问题

**不要跳过**：
- 问题似乎简单（简单 bug 也有根本原因）
- 你在赶时间（匆忙保证返工）
- 经理想要现在修复（系统化比猜测更快）

## 四个阶段

你必须在进入下一个阶段之前完成每个阶段。

### 阶段 1：根本原因调查

**在尝试任何修复之前**：

1. **仔细阅读错误消息**
   - 不要跳过错误或警告
   - 它们通常包含确切的解决方案
   - 完整阅读堆栈跟踪
   - 注意行号、文件路径、错误代码

2. **一致地重现**
   - 你能可靠地触发它吗？
   - 确切的步骤是什么？
   - 每次都发生吗？
   - 如果不可重现 → 收集更多数据，不要猜测

3. **检查最近的更改**
   - 什么更改可能导致此问题？
   - Git diff、最近的提交
   - 新依赖、配置更改
   - 环境差异

4. **在多组件系统中收集证据**

   **当系统有多个组件时（CI → build → signing，API → service → database）：**

   **在建议修复之前，添加诊断工具：**
   ```
   对于每个组件边界：
     - 记录什么数据进入组件
     - 记录什么数据退出组件
     - 验证环境/配置传播
     - 检查每层的状态

   运行一次以收集证据显示在哪里中断
   然后分析证据以识别失败的组件
   然后调查该特定组件
   ```

5. **跟踪数据流**

   **当错误在调用堆栈深处时：**

   - 坏值从哪里开始？
   - 什么用坏值调用了这个？
   - 继续向上跟踪，直到找到源头
   - 在源头修复，不是在症状处

### 阶段 2：模式分析

**在修复之前找到模式**：

1. **找到工作示例**
   - 在同一代码库中找到类似的工作代码
   - 什么工作类似于什么坏了？

2. **与参考进行比较**
   - 如果实现模式，完全阅读参考实现
   - 不要略读 - 读取每一行
   - 在应用之前完全理解模式

3. **识别差异**
   - 工作和坏了之间有什么不同？
   - 列出每个差异，无论多小
   - 不要假设"那不可能"

4. **理解依赖**
   - 这需要什么其他组件？
   - 什么设置、配置、环境？
   - 它做出什么假设？

### 阶段 3：假设和测试

**科学方法**：

1. **形成单一假设**
   - 明确说明："我认为 X 是根本原因因为 Y"
   - 写下来
   - 具体化，不要模糊

2. **最小化测试**
   - 进行最小的可能更改来测试假设
   - 一次一个变量
   - 不要一次修复多个东西

3. **在继续之前验证**
   - 有效？是的 → 阶段 4
   - 无效？形成新假设
   - 不要在上面添加更多修复

4. **当你不知道时**
   - 说"我不理解 X"
   - 不要假装知道
   - 请求帮助
   - 研究更多

### 阶段 4：实施

**修复根本原因，不是症状**：

1. **创建失败测试用例**
   - 最简单的可能重现
   - 如果可能，自动化测试
   - 如果没有框架，一次性测试脚本
   - 修复之前必须有
   - 使用 `superpowers:test-driven-development` 技能编写适当的失败测试

2. **实施单一修复**
   - 解决已识别的根本原因
   - 一次一个更改
   - 没有"既然我在这里"的改进
   - 没有捆绑重构

3. **验证修复**
   - 测试现在通过？
   - 没有其他测试中断？
   - 问题实际解决了？

4. **如果修复不起作用**
   - 停止
   - 计数：你尝试了多少修复？
   - 如果 < 3：返回阶段 1，用新信息重新分析
   - **如果 ≥ 3：停止并质疑架构（阶段 5）**
   - 不要在没有架构讨论的情况下尝试修复 #4

5. **如果 3+ 次修复失败：质疑架构**

   **表明架构问题的模式**：
   - 每次修复在不同地方揭示新的共享状态/耦合/问题
   - 修复需要"大规模重构"来实施
   - 每次修复在其他地方创建新症状

   **停止并质疑基本面**：
   - 这个模式根本合理吗？
   - 我们"只是因为惯性而坚持它"吗？
   - 我们应该重构架构而不是继续修复症状吗？

   **在尝试更多修复之前与人类伙伴讨论**

   这不是失败的假设 - 这是错误的架构。

## 红旗 - 停止并遵循过程

如果你捕捉到自己想：
- "现在快速修复，稍后调查"
- "只是尝试更改 X 看看是否有效"
- "添加多个更改，运行测试"
- "跳过测试，我会手动验证"
- "可能是 X，让我修复它"
- "我不完全理解但这可能有效"
- "模式说 X 但我会以不同方式适应"
- "主要问题：[列出没有调查的修复]"
- 在跟踪数据流之前提出解决方案
- **"再尝试一次修复"（当已经尝试 2+ 次）**
- **每次修复在不同地方揭示新问题**

**所有这些意味着：停止。返回阶段 1。**

**如果 3+ 次修复失败**：质疑架构（见阶段 5）

## 人类伙伴的信号表明你做错了

**观察这些重定向**：
- "不是这样吗？" - 你在没有验证的情况下假设
- "它会显示...？" - 你应该添加证据收集
- "停止猜测" - 你在没有理解的情况下提出修复
- "深度思考这个" - 质疑基本面，不只是症状
- "我们卡住了？"（沮丧） - 你的方法不起作用

**当你看到这些时**：停止。返回阶段 1。

## 快速参考

| 阶段 | 关键活动 | 成功标准 |
|-------|----------|----------|
| **1. 根本原因** | 读取错误、重现、检查更改、收集证据 | 理解什么和为什么 |
| **2. 模式** | 找到工作示例、比较 | 识别差异 |
| **3. 假设** | 形成理论、最小化测试 | 确认或新假设 |
| **4. 实施** | 创建测试、修复、验证 | Bug 解决、测试通过 |

## 真实影响

从调试会话：
- 系统化方法：15-30 分钟修复
- 随机修复方法：2-3 小时混乱
- 首次修复率：95% vs 40%
- 引入新 bug：接近零 vs 常见
